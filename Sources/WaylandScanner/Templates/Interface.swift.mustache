public final class {{interfaceName}}: WlProxyBase, WlProxy {
    var onEvent: (Event) -> Void = { _ in }

    {{methods}}

    {{event}}

    {{enums}}

    public enum Event: WlEventEnum {
        case error(objectId: ObjectId, code: UInt32, message: String)
        case deleteId(id: UInt32)

        static func decode(message: Message) -> Self {
            let r = WLReader(data: message.arguments)
            return switch message.opcode {
            case 0:
                Self.error(objectId: r.readObjectId(), code: r.readUInt(), message: r.readString())
            case 1:
                Self.deleteId(id: r.readObjectId())
            default:
                fatalError("bad wayland server")
            }
        }
    }

    public enum Error: UInt32, WlEnum {  // : WaylandEnum
        case invalidObject
        case invalidMethod
        case noMemory
        case implementation

        // private static func decode() -> Error {

        // }

        // private func encode() {

        // }
    }
}

final class WlRegistry: WlProxyBase, WlProxy {
    var onEvent: (Event) -> Void = { _ in }

    // this must be custom code

    /// Deal with this wisely
    func bind<T>(name: UInt, type: T.Type) -> T where T: WlProxy {
        connection.createProxy(type: T.self)
    }

    public enum Event: WlEventEnum {
        case global(name: UInt32, interface: String, version: UInt32)
        case globalRemove(name: UInt32)

        static func decode(message: Message) -> Self {
            let r = WLReader(data: message.arguments)
            return switch message.opcode {
            case 0:
                Self.global(name: r.readUInt(), interface: r.readString(), version: r.readUInt())
            case 1:
                Self.globalRemove(name: r.readUInt())
            default:
                fatalError("bad wayland server")
            }
        }

    }
}
